#!/usr/local/bin/perl

# A drop-in replacement for Case's cool clone of msgs(1).

# V 1.03 Fixed a bug in DrawScreen that wouldn't print the name or date
#        correctly if the message was posted between midnight and noon
#        (single digit hours). Also, it won't make the subject full of
#        Re:'s on a reply
# V 1.02 Moved around the calls to stty so it dosen't need to be run as often.
#        Added signal handler for SIGcont.
# V 1.01 Changed GetAChar so it dosen't echo the character you get.
#        Added some keypress aliases. Added signal handlers.
# V 1.00 Original release.

require "ctime.pl";

$SIG{'HUP'}='aaaaggghhhh';
$SIG{'INT'}='aaaaggghhhh';
$SIG{'TERM'}='aaaaggghhhh';
$SIG{'CONT'}='sigcont';

select(STDOUT); $|=1;

# This is the directory all the messages are stored in
$msgdir="/var/msgs";

# Find out how many rows are on the screen
open(STTY,"stty -all |");
while(<STTY>) {
  if (m/rows (\d+)/) {
    $numrows=$1 - 1;
    last;
  }
}
close(STTY);
`stty -echo cbreak`;  # No echo, don't wait for a \n

# Find out what message is the next unread one
if (! ($nextmsg=&ReadMsgsrc())) {
  $nextmsg=&FirstMessage();
}
if ($nextmsg > &NumMessages()) {
  $nextmsg=&NumMessages();
}
$maxreadmsg=$nextmsg;


$foo=&NumMessages();
print "There are a total of $foo messages\n";

$done=0;
do {
  &SelectAMessage();
} until ($done);

print "\n\n";
&WriteMsgsrc($maxreadmsg+1);

`stty -cbreak echo`;  # Put things back the way we found it
exit(0);

# This is the end of the script
# Functions follow from here


sub DrawScreen {
# Draws the article selection screen
  local($printmsg,$from,$date,$subject,$printed);

  $printmsg=$nextmsg - int($numrows/2);
  while ($printed < $numrows ) {
 
    if (!open(MSG,"$msgdir/$printmsg")) {  # If that msg dosen't exist...
      print "\n";                          # print a blank line
    } else {
 
      $_=<MSG>;   # Get the author and date
      ($from,$date)=m/^[Ff]rom (\w+) (.+) \d+\:/;
      chop($_=<MSG>);   # Get the subject
      ($subject)=m/^[Ss]ubject\: (.*)/;
 
      # Print a little thingy if this is the current message
      if ($printmsg == $nextmsg) {
        print " > ";
      } else {
         print "   ";
      }
 
      print "$printmsg: \"$subject\" by $from on $date\n";
      $printmsg++; # The message number we just printed the header for
    }
    $printed++;  # How many are on the screen right now
  }
  print "(Space)-Read  (P)-post  (F)-followup  (Q)-quit  (J)-next  (K)-prev (Tab)-rescan";
}

sub SelectAMessage {
# Calls DrawScreen(), then waits to see what you want to do
  local($printmsg,$printed,$msgname,$c,$workspace);

TOP:
  &DrawScreen();

  $c=&GetAChar();
  print "\n";
  if (($c eq " ") || ($c eq "\n")) {  # Space or newline
    &ReadMessage($nextmsg);
  } elsif (($c =~ m/p/i) || ($c =~ m/n/i)) {  # Post or New
    &PostMessage();
  } elsif (($c =~ m/f/i) || ($c =~ m/r/i)) {  # Followup or Reply
    &Followup($nextmsg); 
  } elsif ($c =~ m/q/i) {
    $done=1;
  } elsif ($c =~ m/j/i) {
    $nextmsg++ unless ($nextmsg == &NumMessages());
  } elsif ($c =~ m/k/i) {
    $nextmsg-- unless ($nextmsg == 1);
  
  } elsif ($c =~ m/\d/) {

    # Get a number from the console. There's funky voodoo in here so we
    # can read the first digit when we're not really expecting it, and
    # backspace over stuff
    $workspace="$c";
    print "\nGoto message number: $c";
    do {
      $c=&GetAChar();
      if ($c =~ m/\d/) {
        print "$c";
        $workspace = $workspace . "$c";
      } elsif (($c =~ m/\cH/) || ($c =~ m/\c?/)) {
        if (length($workspace>0)) {
          print " ";
          ($workspace)=($workspace=~m/^(.*)./);
        }
      }
    } until ($c eq "\n");
    print "\n";
    if ($workspace > &NumMessages()) {
      $workspace=&NumMessages();
      print "There's only $workspace messages so far!";
    } elsif ($workspace < &FirstMessage()) {
      $workspace=&FirstMessage();
      print "The oldest message is numbered $workspace";
      $nextmsg=$workspace;
    } else {
      $nextmsg=$workspace;
    }
  }

  # Don't go off the edge of the world
  if ($nextmsg > &NumMessages()) {
    $nextmsg=&NumMessages();
  }
  if ($nextmsg < &FirstMessage()) {
    $nextmsg=&FirstMessage();
  }

  if (!done) {
    goto TOP;    # ACK! A goto... so kill me.
  }
} 

sub ReadMessage {
# Print out the message number given as the first arg
local ($msgnum)=@_;
  local ($numlines,$c);

do {  # Until done reading messages

  print "\n\n\nMessage $nextmsg:\n";

  # Keep track of the highest numbered message we've read
  if ($nextmsg > $maxreadmsg) {
    $maxreadmsg = $nextmsg;
  }

  $numlines=0;  # How many lines we've printed of this message
  open(MSG,"$msgdir/$msgnum");
  while(<MSG>) {
    $numlines++;
    if ($numlines == $numrows-1) {  # Pause after a screenfull
      print "- More - (Space)-continue  (S)-select message  (F)-followup  (P)-post  (Q)-quit";
      $c=&GetAChar();
      print "\n";

      if (($c eq " ") || ($c eq "\n")) { # space and newline
        $numlines=1;
      } elsif (($c =~ m/s/i) || ($c =~ m/i/i)) {  # Select and Index
        return;
      } elsif (($c =~ m/f/i) || ($c =~ m/r/i)) { # Followup and Reply
        &Followup($msgnum);
      } elsif (($c =~ m/p/i) || ($c =~ m/n/i)) {  # Post and New
        &PostMessage();
      } elsif ($c =~ m/q/i) { # Quit
        $done=1;
        return;
      } else {
        $numlines--;
      }
    }
    print ;
  }
  close(MSG);
  
  print "------\n";
  
  $nextmsg++;
  $msgnum++;
  if ($nextmsg > &NumMessages()) {
    print "That was the last message\n------\n";
    print "Press any key to return to the selection screen";
    $c=&GetAChar();
    print "\n";
    return;
  }

  print "(Space)-Next message  (S)-Select messages  (F)-Followup  (P)-Post message";
  $c=&GetAChar();
  print "\n";
  if (($c =~ m/s/i) || ($c =~ m/i/i)) {
    return;
  } elsif (($c =~ m/f/i) || ($c =~ m/r/i)) {
    &Followup($nextmsg - 1);
  } elsif (($c =~ m/p/i) || ($c =~ m/n/i)) {
    &PostMessage();
  } elsif ($c =~ m/q/i) {
    $done=1;
    return;
  }

} until($nextmsg > &NumMessages);  
    
}




sub PostMessage {
# Creates a new message
  local($pid,$filename,$user,$date,$subject,$c,$msgname);

  `stty -cbreak echo`;  # This is the tty mode everyone expects

  $pid=$$;
  $filename="/tmp/newmsgs.$pid";   # Temporary filename for editing
  $user=$ENV{'USER'};
  $date=ctime(time());
  $editor=$ENV{'EDITOR'} ? $ENV{'EDITOR'} : "vi";  # vi is cooler anyway

  # Create the header for the message
  open(FILE,">$filename");
  print FILE "From $user $date";
  print "Subject: ";
  $subject=<STDIN>;
  print FILE "Subject: $subject\n\n";
  close(FILE);
  
  system("$editor +4 $filename");  # Edit the file

  `stty -echo cbreak`;  # Put it back the way we want it

SendForget:
  print "(S)-Send it! (F)-Forget it!";
  $c=&GetAChar();
  print "\n";

  if ($c =~ m/s/i) {
    $msgname=&IncBoundsFile();
    system("mv $filename $msgdir/$msgname");
  } elsif ($c =~ m/f/i) {
    print "Forgetting the whole thing...\n";
    unlink("$filename");
  } else {
    goto SendForget;
  }
}

sub Followup {
# Posts a followup to the message given as the first arg
local ($msgnum)=@_;

  local($pid,$filename,$user,$date,$subject,$c,$msgname,$from);
 
  $pid=$$;
  $filename="/tmp/newmsgs.$pid";
  $user=$ENV{'USER'};
  $date=ctime(time());
  $editor=$ENV{'EDITOR'} ? $ENV{'EDITOR'} : "vi";

  # Get the old sender and subject
  open(MSG,"$msgdir/$msgnum");
  $_=<MSG>;  # This is the sender
  ($from)=m/^[Ff]rom (\w+) /;

  chop($_=<MSG>);  # This is the subject
  ($subject)=m/^[Ss]ubject: (.*)/;
  if ($subject =~ m/^Re\:(.*)/) {
    $subject="Re[2]:$1";
  } elsif ($subject =~ m/^Re\[(\d+)\]\:(.*)/) {
    $subject="Re[". ($1 + 1) ."]:$2";
  } else {
    $subject = "Re: $subject";
  }

  $_=<MSG>;  # Throw out the blank line

  open(FILE,">$filename");
  print FILE "From $user $date";
  print FILE "Subject: $subject\n\n";
  print FILE "$from wrote:\n";

  $numlines=5;
  while (<MSG>) {
    print FILE "\> $_";
    $numlines++;
  }
  print FILE "\n";
  close(MSG);
  close(FILE);
 
  system("$editor +$numlines $filename");
 
  `stty -echo cbreak`;  # Put it back the way we want it

SendForget2:
  print "(S)-Send it! (F)-Forget it!";
  $c=&GetAChar();
  print "\n";
 
  if ($c =~ m/s/i) {
    $msgname=&IncBoundsFile;
    system("mv $filename $msgdir/$msgname");
  } elsif ($c =~ m/f/i) {
    print "Forgetting the whole thing...\n";
    unlink("$filename");
  } else {
    goto SendForget2;
  }

}


sub NumMessages {
# Returns the highest message ID
  local($maxnum);

  open(BOUNDS,"$msgdir/.bounds");
  ($maxnum)=(scalar(<BOUNDS>) =~ m/^\d+\s(\d+)/);
  close(BOUNDS);
  return $maxnum;
}  

sub FirstMessage {
# Returns the number of the first message  

  local($num);

  open(BOUNDS,"$msgdir/.bounds");
  ($num)=(scalar(<BOUNDS>) =~ m/^(\d+)\s/);
  close(BOUNDS);
  return $num;
}
    
  
sub GetAChar {
# Gets one character in cbreak mode
  local($c);

  $c=getc(STDIN);
  return $c;
}

sub ReadMsgsrc {
# Returns the number that's in the .msgsrc file
local(@stuff,$rcfile,$homedir,$num);

  @stuff=getpwnam($ENV{'USER'});
  $homedir=$stuff[7];
  $rcfile=$homedir . "/.msgsrc";
  open(RC,"$rcfile");
  chop($num=<RC>);
  close(RC);
  if ($num eq "") {
    $num=1;
  }
  return $num;
}

sub WriteMsgsrc {
# Saves the number passed as the first arg to the .msgsrc file
local($num)=@_;
local(@stuff,$rcfile,$homedir);

  @stuff=getpwnam($ENV{'USER'});
  $homedir=$stuff[7];
  $rcfile=$homedir . "/.msgsrc";
  open(RC,">$rcfile");
  print RC "$num\n";
  close(RC);
}

sub IncBoundsFile {
# Increments the upper number in the bounds file. Returns the incremented
# number

  local($LOCK_EX,$LOCK_SH,$LOCK_UN,$first,$last,$i);

  $LOCK_SH=1; $LOCK_EX=2; $LOCK_UN=8;

  if (!open(BOUNDS,"+<$msgdir/.bounds")) {
    print "Can't open .bounds: $!\n";
    print "Bounds file is locked. Waiting.";
    for ($i=0; $i==9; $i++) {
      if (open(BOUNDS,"+<$msgdir/.bounds")) {
        last;
      } else {
        print ".";
        sleep(1)
      }
    }
    close(BOUNDS);
    print "Can't aquire lock on $msgdir/.bounds. Get out the picks\n";
    print "Your message has been lost in the ether, BTW...\n";
    return;
  }

  flock(BOUNDS,$LOCK_EX);
  seek(BOUNDS,0,0);
  $_=<BOUNDS>;
  ($first,$last)=(m/(\d+)\s(\d+)/);
  seek(BOUNDS,0,0);
  $last++;
  print BOUNDS "$first $last\n";
  flock(BOUNDS,$LOCK_UN);
  close(BOUNDS);

  return $last;
}


sub aaaaggghhhh {
# Saves the .msgsrc file before dying

  &WriteMsgsrc($maxreadmsg+1);

  `stty -cbreak echo`; 
  exit(1);
}

sub sigcont {
# Puts the terminal back into cool mode. Hopefully your shell takes care of
# putting it into normal mode when you hit ^Z
  if (! -f "/tmp/newmsgs.$$") {
    `stty cbreak -echo`;
    &DrawScreen();
  }
}
