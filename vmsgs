#!/usr/bin/perl

# vmsgs 2.0 - An improvement for a drop-in replacement for Kees' cool
# clone of msgs(1).

#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

# Quick info:
# Signature files are supported.  They're called .msgssig
# Kill files are supported.  Use the -k command line option to ignore
#   a kill file already in place.  The kill file is called .msgskill
#   The format consists of each line having a keyword and a value.  The 
#   values may be simple text strings, or any valid Perl regex
#     uid <UserID> - And msgs owned b y that UID are skipped
#     from <username> - Any msg written by user "username" are skipped.  It
#       looks in the From header to see who wrote it
#     subject <text> - Skipps any msgs where <text> appears in the Subject:
#       header
#     any <text> - Skipps and msg where <text> appears anywhere in the msg
# When composing a message, it looks at the MSGS_EDITOR and EDITOR env
#   variables to tell what editor to run.  If neither is set, it uses vi

############################################################################
# Revision History
#
# V 2.98.1 vmsgs.debug files are now only created in the users home directory
#        (StartDebug) 9/28/00
# V 2.98 .msgsrand file is now supported for the "interesting" $0s (PickArgv0)
#        11/10/99
# V 2.97 Lines could get cut off if some lines in the post exceeded the 
#        width of the terminal.  Now, it chops the lines up as it reads
#        them in to fit ther terminal's width (AsyncRead)  7/14/99
# V 2.96 Changed a bunch of stuff when we went to the new Lucien machine.
#        The main problem was that sigalrm-s weren't getting sent any more, so
#         looking for new messages is now done with polling  4/12/99
# V 2.95 Added "w" key for writing the current msg to a file (SelectMessage,
#        ReadMessage, WriteFile(new), GetHomeDir(new), DoHelp) 11/3/98
# V 2.94 Added scrolling msg display instead of redraw (ReadMessage,
#        GetCommandLine).  Added support for an rc file (.vmsgsrc) so you
#        don't have to remember all the command line switches (GetCommandLine)
#        Fixed getting the user and host names (main,PostMessage,Followup)
#        .msgsrc should now be correct after an abort with ^C (aaaaggghhhh,
#        InitMsgStat) 9/17/97
# V 2.93 Enabled use of the arrow keys - added a call to keypad() (main)
#        Created a wrapper for getch to handle reading from the child on
#        async reads - should fix random segfaults and bus errors (sigIO,
#        RealSigIO,GetAKey(new),InitMasterMsgHash).  Prints blank line for
#        non-existant msgs instead of barfing (PrintMsgInfoLine) 9/11/97
# V 2.92 Updated header parse function to look for non-whitespace chars
#        for the author instead of word characters (ParseHeader)
#        Spread out writes to the screen to look for segfaults 
#        (PrintMsgsInfoLine) 9/9/97
# V 2.91 Reads from the server are now done with Async I/O (LoadHeader,
#        LoadBody, AsyncRead(new), sigIO(new)) 8/22/97
# V 2.90 Big rewrite to interface more smoothly with msgs.pl.  Headers and
#        bodies are now only read in when absolutely needed - should
#        speed up startup time.  Content-length: header now used properly.
#        Cheesy read ahead implimented - automaticly reads in three msgs.
#        8/18/97
###########################################################################
# V 2.33 Added -m command line option to start reading at a given msg #
#        (GetCommandLine, InitMsgStat).  If reading remotely, it only
#        loads 30 msgs prior to the current one instead of 100 for local
#        reading (InitMsgStat) 8/14/97
# V 2.32 Fixed a bug where a cached msg wasn't being used properly
#        (dreferencing a reference incorrectly) (Followup, MailReply) 8/5/97
# V 2.31 Help screen wasn't clearing the window before writing to it
#        (DoHelp).  Mail wasn't getting sent to the right address with remote
#        postings (MailReply).  Return email address wasn't always right
#        (PostMessage, Followup)  msgsrc is now centrally located.
#        InitMsgStat, aaaaggghhhh, main()) 7/30/97
# V 2.30 Support for remote msg reading.  Lots of new stuff rewritten to
#        use the msgsd API (msgsd.pl)  (FirstMessage, NumMessages,
#        CreateMsgsArray, ReadMessage, PostMessage, Followup, MailReply,
#        sigalrm, ShouldKillfile).  Msgs can be cached (CreateMsgsArray,
#        ReadMessage, Followup, sigalrm) 7/29/97
# V 2.20 Messages are now seperated by 1000s (/var/msgs/13000.dir).
#        (CreateMsgsArray, PostMessage, Followup, ReadMessage, IncBoundsFile,
#        sigalrm, ShouldKillFile, SearchMessages, GetMsgDir2(new)).
#        Temoprary messages are now stored in the user's home directory
#        instead of /tmp (PostMessage, Followup).  Now you can mail a reply
#        to someone's message (SelectMessage, ReadMessage, MailReply(new)).
#        4/29/97
# V 2.12 If you put in a blank subject in a new message, it'll ask if you
#        want to forget the message, like in elm. (PostMessage)  3/12/97
# V 2.11 Make it so the sig is added before it fires up the editor
#        (PostMessage, Followup)   3/6/97
# V 2.1  Added support for a .msgssig file (PostMessage, Followup,
#        AppendSig(new)).  Preliminary work started on threading during read
#        mode
# V 2.00 Added 2 columns to the display so there's room for 5-digit msg IDs
#        (PrintMsgInfoLine).  New msg notification now works correctly
#        (sigalrm).
# V 1.95 Fixed an oversight where it'd get into an endless loop if you killfile
#        everything (main()). Added -k flag to ignore the kill file
#        (GetCommandLine, ReadKillfile).  Dosen't core dump when you ^C
#        (aaaaggghhhh).  Fixed the segfault returning from search mode -
#        forgot a local() (SearchMessages).  Message count on the title
#        bar is now always correct (SelectMessage).  Did an audit of calls
#        to refresh(), touchwin() and clear() to try and get rid of some
#        of the redraws - it didn't help much.
# V 1.94 Made the changes to kill files (.msgskill) so it works right. Added
#        uid kills (ShouldKillfile, CreateMsgsArray, main(), ReadKillfile)
# V 1.93 Added the -all flag (it'll only read 100 messages prior to the
#        current message, unless you give it -all. This will speed up startup
#        time). Added a umask call so msgs are set world-readable (main(),.
#        InitMsgsStat)
# V 1.92 Fixed a bug where newly arrived messages' dates and lengths were not
#        parsed correctly (sigalrm). Messages with no body are now handled
#        correctly (ReadMessage).
# V 1.91 Selection screen now scrolled instead of redrawn (SelectMessage).
#        Support for recognizing pre-posted messages (IncBoundsFile). Quicker
#        updates of newly arrived messages (now reads only new messages,
#        instead of all of them) (sigalrm).
# V 1.90 Complete rewrite. Changed over to curses stuff. Added searching,
#        killfiles. Info about messages is now stored in a hash (to reduce
#        disk I/O while running) and passed around by a reference to that
#        hash.
#############################################################################
# V 1.03 Fixed a bug in DrawScreen that wouldn't print the name or date
#        correctly if the message was posted between midnight and noon
#        (single digit hours). Also, it won't make the subject full of
#        Re:'s on a reply  9/23/96
# V 1.02 Moved around the calls to stty so it dosen't need to be run as often.
#        Added signal handler for SIGcont.
# V 1.01 Changed GetAChar so it dosen't echo the character you get.
#        Added some keypress aliases. Added signal handlers.  8/30/96
# V 1.00 Original release.  8/29/96

#############################################################################
# Start of main script

$DEBUG=1;
@argvs=("superfly tnt","gutter trash","likes cake",
        "kooler than jesus","new wave","get some!",
        "better than a sharp stick in the eye",
        "                nosey, aint ya?","the cool one");

# Some initialization stuff
#$|=1;

($LAST_SPOOL_READ) = (scalar(localtime()) =~ m/:(\d+):/);

push(@INC,".");  # So we can find msgs.pl if it's in the local directory
unshift(@INC,"/usr/local/encap/msgs-pack-1.0/lib");
use Curses;
use Socket;
require "msgs.pl";
require "flush.pl";
#require "getopts.pl";

umask(022); # World and group readable
srand();

&StartDebug();

&SetupSignals();

#&Getopts('rm:kcn'); # -r remote, -m machine name, -c cache, -n no cache,
#                    # -k ignore kill file, -a read ahead
&GetCommandLine();

if ($opt_h) {
  &DoCommandLineHelp();
  exit(0);
}

# The recursion level of the selection window
$recurse_select=0;

# Did sigalrm notice any new messages last time through?
$newmessages=0;

$LOCAL = ! $opt_r;  # Local and remote reading
$OLDSCHOOL=0;  # For the msgs.pl library
$0 = &PickArgv0(@argvs);
#$0=$argvs[ int(rand($#argvs+1)) ];
$VERSION="2.97";
$CACHE_MSGS = ($opt_c || (! $LOCAL)) && (! $opt_n);
&DEBUG("\$CACHE_MSGS is $CACHE_MSGS\n");
$PID=$$;
$SERVER=$opt_s if ($opt_s);

if ($ENV{'MSGS_EDITOR'}) {
  $EDITOR=$ENV{'MSGS_EDITOR'};
} elsif ($ENV{'EDITOR'}) {
  $EDITOR=$ENV{'EDITOR'};
} else {
  $EDITOR="vi";  # vi is cooler anyway
}


# Make sure read ahead value makes sense
if ($opt_a) {
  if ($opt_a < 1) {
    $opt_a = 1;
  } elsif ($opt_a > 20) {
    $opt_a = 20;
  }
} else {
  $opt_a = 5;
}

if ($LOCAL) {
  &DEBUG("Reading is LOCAL!!\n");
} else {
  &DEBUG("Reading is REMOTE!!\n");
}

&DEBUG("Starting up msgs API\n");
&InitializeMsgsAPI();
$AUTHOR= $LOCAL ? $ENV{'USER'} || $ENV{'LOGNAME'} :  &GetLogname();
{
  my($user,$host);
  chomp($user=`whoami`);
  chomp($host=`hostname`);
  $EMAIL= $ENV{'EMAIL'} || "$user\@$host";
}

$msgstat=&InitMsgStat();

if ($opt_C) {  # Catch up without reading msgs
  print "Catching up...";
  &SetRC(&NumMessages());
  print "\n";
  exit(0);
}
  
&ReadKillfile();
&InitMasterMsgHash($msgstat->{currmsg},&GetLines());

if (! keys(%{$master_msg_hash})) {
  print "\nYou've killfiled _everything_! What's up with that?\n\n";
  exit 0;
} else {
  while(!defined($master_msg_hash->{$msgstat->{'currmsg'}})) {
    $msgstat->{currmsg}--;
  }
}

&DEBUG("Starting up Curses...\n");
$curses_on=1;
initscr();  # Init curses stuff
halfdelay(1); # Block 1/10 sec when reading a char
noecho(); # Don't echo received characters
keypad(1); # Allow function keys and arrow keys

#&DEBUG("Setting the alarm\n");
#alarm(60);


# Here's where we actually start up the user interface
&DEBUG("Going to user mode!\n");
$msgstat->{'mode'}="selection";
ungetch(ord("\cL"));
&SelectMessage($master_msg_hash);

&DEBUG("Returned from user mode\n");

DoneCursesWindows(%screen);
if (!&SetRC($msgstat->{maxmsg}+1)) {
  print "Your msgsrc didn't save correctly...\n";
}
print "\n";
exit(0);

#############################################################################
#
# End of the main script. Functions follow from here.
#
#############################################################################


sub PickArgv0 {
# Picks a message to display in the ps output.  If a .msgsrand file
# exists, use those instead of the builtins
my(@argvs) = @_;
  my $filename = $ENV{'HOME'} . "/.msgsrand";

  if (-f $filename ) {
    @argvs = ();
    open(FILE,$filename);
    while(<FILE>) {
      chomp;
      next unless (m/\S/);  # make sure this isn't a blank line
      push(@argvs,$_);
    }
    close(FILE);
  }

  "vmsgs: " . $argvs[ int(rand($#argvs+1)) ];
} # end PickArgv0

sub InitMsgStat {
# Initializes the msgstat structure which includes:
# $msgstat{currmsg} : The current (usu. highlited) message
# $msgstat{maxmsg}  : The highest numbered message you've read so far
# $msgstat{firstmsg}: The ID number of the first message (from .bounds)
# $msgstat{lastmsg} : The ID number of the last message
# $msgstat{firstloaded} : The ID number of the first msg headers loaded
# $msgstat{lastloaded} : The ID number of the last msg headers loaded
  my($tmp,%msgstat);

&DEBUG("In InitMsgStat\n");

  if ($opt_m) {
    $msgstat{currmsg}=$opt_m;
  } else {
    if (($tmp=&ReadRC())<=1) {
      $msgstat{currmsg}=&NumMessages();
    } else {
      $msgstat{currmsg}=$tmp;
    }
  }

  $msgstat{maxmsg}=$msgstat{currmsg} - 1;
  $msgstat{firstmsg}=&FirstMessage();

  $msgstat{lastmsg}=&NumMessages();
  $msgstat{firstloaded}=1000000;
  $msgstat{lastloaded}=0;

  if ($msgstat{currmsg} > $msgstat{lastmsg}) {
    $msgstat{currmsg}=$msgstat{lastmsg};
  }
  &DEBUG("currmsg is " . $msgstat{currmsg} . "\n");
  &DEBUG("maxmsg is " . $msgstat{maxmsg} . "\n");
  &DEBUG("firmsmsg is " . $msgstat{firstmsg} . "\n");
  &DEBUG("lastmsg is " . $msgstat{lastmsg} . "\n");
  &DEBUG("firstloaded is " . $msgstat{firstloaded} . "\n");
  &DEBUG("lastloaded is " . $msgstat{lastloaded} . "\n");

  return \%msgstat;
}


sub ReadKillfile {
# Reads in the killfile .msgskill and creates the %kill_subject, %kill_from
# and %kill_any arrays
my(@stuff,$killfile);

  if ($opt_k) {
    &DEBUG("Skipping kill file 'cause of -k switch\n");
    return;
  }

  &DEBUG("In ReadKillFile\n");

  if (open(KILL,$ENV{'HOME'} . "/.msgskill") ||
      open(KILL,$ENV{'HOME'} . "/.killfile")) {

    while(<KILL>) {
      chop;
      if (m/^subject (.*)/) {
        $kill_subject{$1}=1;
        &DEBUG("killing subject $1\n");
      } elsif (m/^from (.*)/) {
        $kill_from{$1}=1;
        &DEBUG("killing from $1\n");
      } elsif (m/^any (.*)/) {
        $kill_any{$1}=1;
        &DEBUG("killing any $1\n");
      } elsif (m/uid (.*)/) {
        $kill_uid{$1}=1;
        &DEBUG("killing uid $1\n");
      }
    }
    close(KILL);

  } else {
    &DEBUG("problem opening killfile\n");
  }
} # end ReadKillfile



sub ShouldKillFile {
# Returns 1 if the given message should be killed
my($msgnum,$from,$subject,$uid)=@_;
my($killfrom,$killsubject,$killuid,$msgdir2);

  my($msgline);

  &DEBUG("In ShouldKillfile\($msgnum\)\n");
  &DEBUG("from $from subject $subject uid $uid\n");

  foreach $killfrom (keys(%kill_from)) {
    if ($from =~ m/$killfrom/) {
      &DEBUG("killing from\n");
      return 1;
    }
  }

  foreach $killuid (keys(%kill_uid)) {
    if ($uid eq $killuid) {
      &DEBUG("killing uid\n");
      return 1;
    }
  }

  foreach $killsubject (keys(%kill_subject)) {
    if ($subject =~ m/$killsubject/) {
      &DEBUG("killing subject\n");
      return 1;
    }
  }

  if (keys(%kill_any) == ()) {
    return 0;
  } else {
    my($text);

    $text=&LoadBody($msg);
    if ( scalar(@{$text}) == 0) {
      &DEBUG("LoadBody returned nothing for message $msg\n");
    }

    foreach $msgline ( @{$text} ) {
      if (grep($msgline =~ /$_/,keys(%kill_any))) {
        return 1;
      }
    }
  }

  return 0;
} # end ShouldKillFile

  

sub FirstMessage {
# Returns the number of the first message
  my(@array);

  @array=&GetBounds();
  if (! @array) {
    &DEBUG("FirstMessage: GetBounds array is null?!?\n");
    return 1;
  } else {

&DEBUG(join("| |","FirstMessage: array is",@array,"\n"));
    return $array[0];
  }
} # end FirstMessage

sub NumMessages{
# Returns the highest message ID
  my(@array);

  @array=&GetBounds();
&DEBUG("NumMessages: array length is " . scalar(@array) . "\n");
&DEBUG("NumMessages: array is |" . $array[0] . "|" . $array[1] . "|\n");
  if (! @array) {
    &DEBUG("NumMessages: GetBounds array is null?!?\n");
    return 10000;
  } else {
&DEBUG(join("| |","NumMessages: array is",@array,"\n"));
    return $array[1];
  }
} # end NumMessages

  

sub InitMasterMsgHash {
# Loads in the first few messages.
my($current,$lines)=@_;
  my($msg);

  print "Loading initial msgs ";

  &DEBUG("InitMasterMsgHash\($current,$lines\)\n");
  &DEBUG("InitMasterMsgHash: lastmsg is " . $msgstat->{'lastmsg'} . "\n");

  foreach $msg ( ($current - int($lines/2)) .. ($current + int($lines/2))) {
    last if ($msg > ($msgstat->{'lastmsg'}));
    &DEBUG("InitMasterMsgHash: Loading msg $msg\n");
    LoadMsg($msg);
    print "." if (! ($msg & 3));

    while ($async_ready) {
      &RealSigIO();
    }
  }

  print "\n";
} # end InitMasterMsgHash


sub ParseHeader {
# Parses the incoming header and fills in the msgs hash
my($msg,$header)=@_;
  my($from,$email,$date,$subject,$followup,$numlines,$uid);

  &DEBUG("In ParseHeader\($msg,$header\)\n");

  foreach ( @{$header} ) {
    chomp;
    if (m/^from (\S+) \((\S+)\) (.*)$/i) {
      $from=$1;
      $email=$2;
      $date=$3;
    } elsif (m/^from (\S+) (.*)$/i) {
      $from=$1;
      $date=$2;
      $email="";
    } elsif (m/^subject\: (.*)/i) {
      $subject=$1;
    } elsif (m/^followup\-to\: (\d*)/i) {
      $followup=$1;
    } elsif (m/^date\: (.*)/i) {
      $date=$1;
    } elsif (m/^content\-length\: (\d*)/i) {
      $numlines=$1;
    }
  }
  $uid = $LOCAL ? (stat("$msgdir/$msg"))[4] : -1;

  $master_msg_hash->{$msg}->{'from'}=$from;
  $master_msg_hash->{$msg}->{'date'}=$date;
  $master_msg_hash->{$msg}->{'uid'}=$uid;
  $master_msg_hash->{$msg}->{'subject'}=$subject;
  $master_msg_hash->{$msg}->{'numlines'}= $numlines ? $numlines : "";
  $master_msg_hash->{$msg}->{'followup'}=$followup;
  $master_msg_hash->{$msg}->{'email'}=$email;
  $master_msg_hash->{$msg}->{'uid'}=$uid;

  push(@{$master_msg_hash->{$followup}->{'follows'}}, $msg);
} # end ParseHeader



sub LoadHeader {
# Returns a reference to an array containing the headers of the given
# msg.  If $CACHE_MSGS is true, the headers are saved too.
my($msg)=@_;
  my($header,$from,$email,$date,$subject,$followup,$date,$numlines,$uid);

  return if ($msg > $msgstat->{'lastmsg'});

  &DEBUG("In LoadHeader\($msg\)\n");

  if ($master_msg_hash->{$msg}->{'header'}) {
    &DEBUG("LoadHeader: Returning cached header\n");
    return $master_msg_hash->{$msg}->{'header'};
  } else {
    &DEBUG("LoadHeader: getting header from server\n");
    $header=&AsyncRead($msg,"header");

    if (! scalar(@{$header})) {
      # Some problem.  Try resetting the net connection
      &DEBUG("LoadHeader: Server returned an error. Resetting connection...\n");
      &InitializeMsgsAPI();
      &DEBUG("LoadHeader: Trying to get it again\n");
      $header=[ &GetHeader($msg) ];
    }

    if (! $master_msg_hash->{$msg}->{'from'}) {
      &DEBUG("LoadHeader: parsing header\n");

      &ParseHeader($msg,$header);
    }

    if ($msgstat->{firstloaded} > $msg) {
      &DEBUG("LoadHeader: updating firstloaded to $msg\n");
      $msgstat->{firstloaded} = $msg;
    } elsif ($msgstat->{lastloaded} < $msg) {
      &DEBUG("LoadHeader: updating lastloaded to $msg\n");
      $msgstat->{lastloaded} = $msg;
    }


    if ($CACHE_MSGS) {
      &DEBUG("LoadHeader: Caching header\n");
      $master_msg_hash->{$msg}->{'header'} = $header;
    }

    return $header;
  }
} # end LoadHeader


sub LoadBody {
# Returns a reference to an array containing the body of the given
# msg.  If $CACHE_MSGS is true, the headers are saved too.
my($msg)=@_;
  my($body);

  return if ($msg > $msgstat->{'lastmsg'});

  &DEBUG("In LoadBody\($msg\)\n");

  if ($master_msg_hash->{$msg}->{'text'}) {
    &DEBUG("LoadBody: returning cached body\n");
    return $master_msg_hash->{$msg}->{'text'};
  } else {
    &DEBUG("LoadBody: Getting body from server\n");
    $body=&AsyncRead($msg,"text");
    
    if (! scalar(@{$body})) {
      # Some problem.  Try resetting the net connection
      &DEBUG("LoadBody: server returned error.  Resetting connection...\n");
      &InitializeMsgsAPI();
      &DEBUG("LoadBody: regetting body\n");
      $body=[ &GetBody($msg) ];
    }

    if (! $master_msg_hash->{$msg}->{'numlines'}) {
      $master_msg_hash->{$msg}->{'numlines'} = scalar(@{$body});
      &DEBUG("LoadBody: counting lines. " . 
             $master_msg_hash->{$msg}->{'numlines'} . " lines\n");
    }

    if ($CACHE_MSGS) {
      &DEBUG("LoadBody: caching body\n");
      $master_msg_hash->{$msg}->{'text'} = $body;

    }

    return $body;
  }
} # end LoadBody
  


sub LoadMsg {
# Loads one message into the msg hash referenced to by $master_msg_hash
my($msg)=@_;
  my($header,$text);

&DEBUG("LoadMsg: loading msg $msg\n");

  $header = &LoadHeader($msg);
  if ( ! scalar(@{$header})) {
    &DEBUG("GetHeader returned nothing for msg $msg\n");
  } else {
    &DEBUG("Msg $msg has " . scalar(@{$header}) . " headers\n");
  }

  if ($LOCAL) {
    $text=&LoadBody($msg);
    if ( ! scalar(@{$text}) ) {
      &DEBUG("GetBody returned nothing for msg $msg\n");
    } 
  }

  if (ShouldKillFile($msg,
                     $master_msg_hash->{$msg}->{from},
                     $master_msg_hash->{$msg}->{subject},
                     $master_msg_hash->{$msg}->{uid})) {
    $master_msg_hash->{$msg}=0;
    &DEBUG("Skipping msg $msg 'cause it's killfiled\n");

  }
} # end LoadMsg
  


sub StartDebug {
# opens the debug file for writing

  my $filename = $ENV{'HOME'} . "/vmsgs.debug";
  if ($DEBUG) {
    open(DEBUG,">$filename");
    select(DEBUG);
    $|=1;
    select(STDOUT);

    print DEBUG "vmsgs $VERSION\n";
  } else {
    open(DEBUG,">/dev/null");
  }
} # end StartDebug


sub DEBUG {
# prints debugging messages or not
  my($time);
  
  ($time) = (scalar(localtime()) =~ m/\w+\s+(\w+\s+\d+\s+\d+\:\d+\:\d+)/);
  print DEBUG "**" if ($PID != $$);
  print DEBUG "$time [$$]: @_";
} # end DEBUG


sub SetupSignals {
# Initializes signal handlers

  $SIG{'HUP'}=\&aaaaggghhhh;
  $SIG{'INT'}=\&aaaaggghhhh;
  $SIG{'TERM'}=\&aaaaggghhhh;
  $SIG{'CONT'}=\&sigcont;
#  $SIG{'ALRM'}=\&sigalrm;
#  &DEBUG("sigalrm points to " . $SIG{'ALRM'} . "\n");
} # end SetupSignals


sub GetANumber {
# Called by SelectMessage when you try to type in a number. The first arg is
# the first number you typed. GetANumber returns the number or 0 if escape
# was pressed. The second arg is the list of available messages to choose
# from
my($workspace,$msghash)=@_;
my($char,$numberwin,$lowkey,$highkey);

  &DEBUG("In GetANumber\n");

  $lowkey=&GetLowestKey($msghash);
  $highkey=&GetHighestKey($msghash);

  $numberwin=newwin(5,50,(int($LINES/2)-2),(int($COLS/2)-25));

  do {
    addstr($numberwin,2,2,"Goto message number: $workspace");
    clrtoeol($numberwin);
    box($numberwin,"|","-");

    do {
      refresh($numberwin);
      $char=GetAKey();
      if (($char =~ m/\d/) && (length($workspace)<6) ) {  # Add another number
        addch($numberwin,"$char");
        $workspace=$workspace."$char";
      } elsif (($char eq "\cH" ) || ($char eq "\c?" )) { # Backspace
        if (length($workspace>0) ) {
          addch($numberwin,"\cH \cH");
          ($workspace) = ($workspace =~ m/^(.*)./);
        }
      } elsif ($char eq "^[") {  # Cancel out if you hit escape
        delwin($numberwin);
        &DEBUG("GetANumber returning 0\n");
        return 0;
      }
    } until ($char eq "\n");

    if ($workspace eq "") {
      &DEBUG("GetANumber returning 0\n");
      return 0;
    } elsif ( ($workspace > $highkey) ||
         ($workspace < $lowkey) ) {
      beep();
      addstr($numberwin,1,2,"Message number must be between $lowkey and $highkey");
    refresh($numberwin);
      $workspace="";
#    } elsif (! defined($msghash->{$workspace})) {
#      beep();
#      addstr($numberwin,1,2,"That message does not exist. It's been deleted or killfiled");
#      refresh($numberwin);
#      $workspace="";
    } else {
      delwin($numberwin);
      &DEBUG("GetANumber returning $workspace\n");
      return $workspace;
    }
  } until (0) # Get out of this loop only with return
} # end GetANumber

sub numerically {$a <=> $b;} # Used by the sorts below
sub revnumerically {$b <=> $a;}

sub GetHighestKey {
# Returns the highest numbered key of the given hash
my($hash)=@_;

  return $msgstat->{'lastmsg'};
#  return((sort(revnumerically keys(%{$hash})))[0]);
}

sub GetLowestKey {
# Returns the lowest numbered key of the given hash
my($hash)=@_;

  return $msgstat->{'firstmsg'};
#  return( (sort(numerically keys(%{$hash})))[0] );
}

sub PrintMsgInfoLine {
# Prints the info line in the selection screen for the given message
my($screen,$msgnum,$msghash)=@_;

  return if ($msgnum > $msgstat->{'lastmsg'});

  if (! $msghash->{$msgnum}->{'from'}) {
    &DEBUG("PrintMsgInfoLine: Loading header for msg $msgnum\n");
    &LoadHeader($msgnum);
  }

  &DEBUG("printing info for message $msgnum\n");
  attron($screen,A_BOLD) if ($msgnum > $msgstat->{maxmsg});

  addstr($screen,"$msgnum" . " "x(7-length($msgnum)));
  if (! $msghash->{$msgnum}->{from}) {
    addstr($screen,"\n");
  } else {
    if ($DEBUG) {
      addstr($screen,substr($msghash->{$msgnum}->{from},0,12));
      addstr($screen," "x(12-length($msghash->{$msgnum}->{from})));
      addstr($screen,substr($msghash->{$msgnum}->{numlines},0,5));
      addstr($screen," "x(5-length($msghash->{$msgnum}->{numlines})));
      addstr($screen,substr($msghash->{$msgnum}->{subject},0,52));
      addstr($screen,"\n");
    } else {
      addstr(substr($msghash->{$msgnum}->{from},0,20)
           . " "x(20-length($msghash->{$msgnum}->{from}))
           . substr($msghash->{$msgnum}->{numlines},0,5)
           . " "x(5-length($msghash->{$msgnum}->{numlines}))
           . substr($msghash->{$msgnum}->{subject},0,48)
           . "\n");
    }
  }

  attroff($screen,A_BOLD);
} # end PrintMsgInfoLine



sub DisplaySelectScreen {
# Called by SelectMessage to create the selection screen. SelectMessage
# then uses scrolling to move up and down. It returns the line number
# the current message is on.
my($screen,$currmsg,$msghash)=@_;

&DEBUG("In DisplaySelectScreen. \$currmsg is $currmsg\n");

  my($numprinted,$msgindex,$printmsg,$fromtop,$firstprinted,$lastprinted);

  move($screen,0,0);
  $numprinted=0;

  # Find out what message number is at the top of the screen
  $printmsg=($msgstat->{currmsg}-1);
  $msgindex=0;
  while (($msgindex < (int($LINES/2)-2)) && ($printmsg > $lowkey)) {
#    if (defined($msghash->{$printmsg})) {
      $msgindex++;
#    }
    $printmsg--;
  }

  $firstprinted=$printmsg;

  while ($numprinted < ($LINES-2)) {

    if ($primtmsg > $msgstat->{'lastmsg'}) { # if this message dosen't exist
&DEBUG("Printing a blank line for message $printmsg\n");
      addstr($currentscreen,"\n");  # Print a blank line
      $numprinted++;
    } else {

        # Go into reverse text mode if this is the current message
        if ($printmsg == $currmsg) {
          attron($screen,A_REVERSE);
          $fromtop=$numprinted;
        } elsif ($printmsg > $msgstat->{maxmsg}) {
          attron($screen,A_BOLD);
        }
&DEBUG("Before PrintMsgInfoLine for message $printmsg\n");
        &PrintMsgInfoLine($screen,$printmsg,$msghash);
        attroff($screen,A_BOLD);
        attroff($screen,A_REVERSE);

        $numprinted++;
    }

#    do {
      $printmsg++;
&DEBUG("Searching for next to print \$printmsg is $printmsg\n");
#    } until (($printmsg > $highkey) || defined($msghash->{$printmsg}) );
  }

  $lastprinted=$printmsg-1;

&DEBUG("refresh 508\n");
  refresh($currentscreen);
  touchwin($currentscreen);
  refresh($currentscreen);
  return ($firstprinted,$fromtop,$lastprinted);
} # end DisplaySelectScreen


sub NextMessageForward {
# Scans forward from the given message number for the next valid number
my($currmsg,$msghash,$highkey)=@_;

  return ($currmsg+1);

#  do {
#    $currmsg++;
#  } until (defined($msghash->{$currmsg}) || ($currmsg > $highkey));
#
#  return $currmsg;
} # end NextMessageForward

sub NextMessageBackward {
my($currmsg,$msghash,$lowkey)=@_;

  if ($currmsg > $lowkey) {
    return ($currmsg-1);
  } else {
    return $lowkey;
  }

#  do {
#    $currmsg--;
#  } until (defined($msghash->{$currmsg}) || ($currmsg < $lowkey));
#
#  return $currmsg;
} # end NextMessageBackward


sub ScrollSelectionUp {
# Scrolls the Message selection window up one line and displays a new
# message at the bottom of the screen

  my($c);

  $c=&NextMessageForward($msgstat->{currmsg},$msghash,$highkey);
&DEBUG("Trying to scroll up \$c: $c \$msgstat->{currmsg}: $msgstat->{currmsg}\n");
  if (($c != $msgstat->{currmsg}) && ($c <= $msgstat->{'lastmsg'})) {
    # If it changed

&DEBUG("Scrolling up \$fromtop: $fromtop \$firstprinted: $firstprinted \$lastprinted: $lastprinted\n");

    scrollok($currentscreen,1);
    scrl($currentscreen,1);
    scrollok($currentscreen,0);

    # Unhilite the old current message
    move($currentscreen,$fromtop-1,0);
    &DEBUG("Unhiliting msg " . $msgstat->{currmsg} . "\n");
    &PrintMsgInfoLine($currentscreen,$msgstat->{currmsg},$msghash);

    # Hilite the new current message
    attron($currentscreen,A_REVERSE);
    &DEBUG("Hiliting msg $c\n");
    &PrintMsgInfoLine($currentscreen,$c,$msghash);
    attroff($currentscreen,A_REVERSE);

    $msgstat->{currmsg}=$c;

    # Display a new message at the bottom
    move($currentscreen,$LINES-3,0);
    $c=&NextMessageForward($lastprinted,$msghash,$highkey);
    if ($c != $lastprinted) {
      $lastprinted=$c;
      &DEBUG("Printing msg $lastprinted at bottom\n");
      &PrintMsgInfoLine($currentscreen,$lastprinted,$msghash);
    }
    if ($firstprinted <= $lowkey) {
      $firstprinted++;
    } else {
      $c=&NextMessageForward($firstprinted,$msghash,$highkey);
      if ($c != $firstprinted) {
        $firstprinted=$c;
      }
    }
  }
} # end ScrollSelectionUp


sub ScrollSelectionDown {
# Scrolls the Message selection window down one line and displays a new
# message at the top of the screen

  my($c);

  $c=&NextMessageBackward($msgstat->{currmsg},$msghash,$lowkey);
  if ($c != $msgstat->{currmsg}) { # If changed

&DEBUG("Scrolling down \$fromtop: $fromtop \$firstprinted: $firstprinted \$lastprinted: $lastprinted\n");

    scrollok($currentscreen,1);
    scrl($currentscreen,-1);
    scrollok($currentscreen,0);

    # Hilite the new current message
    move($currentscreen,$fromtop,$0);
    attron($currentscreen,A_REVERSE);
    &PrintMsgInfoLine($currentscreen,$c,$msghash);
    attroff($currentscreen,A_REVERSE);

    # Unhilite the old current message
    &PrintMsgInfoLine($currentscreen,$msgstat->{currmsg},$msghash);

    $msgstat->{currmsg}=$c;

    # Display a new message at the top
    move($currentscreen,0,0);
    $c=&NextMessageBackward($firstprinted,$msghash,$lowkey);
    if ($c != $firstprinted) {
      $firstprinted=$c;
      &PrintMsgInfoLine($currentscreen,$firstprinted,$msghash);
    }
    if ($lastprinted >= $highkey) {
      $lastprinted--;
    } else {
      $c=&NextMessageBackward($lastprinted,$msghash,$lowkey);
      if ($c != $lastprinted) {
        $lastprinted=$c;
      }
    }
  }
} # end ScrollSelectionDown


sub SelectMessage {
# The Message Selection screen
local($msghash)=@_;
my($totalmsgs,$newmsgs,$oldnewmsgs,$timestr,$percentshown);
my($numprinted,$printmsg,$from,$date,$subject,$numlines,$c,$msgindex);
local($firstprinted,$lastprinted,$fromtop,$lowkey,$highkey,$legalkey);
local($titlebar,$bottombar,$currentscreen)=();

  $lowkey=&GetLowestKey($msghash);
  $highkey=&GetHighestKey($msghash);
  $recurse_select++;
&DEBUG("SelectMessage: \$lowkey:$lowkey \$highkey:$highkey\n");

  $titlebar=newwin(1,0,0,0) || die "titlebar";
  scrollok($titlebar,0);
  $bottombar=newwin(1,0,$LINES-1,0) || die "bottombar";

  # Create the selection window
  $currentscreen=newwin($LINES-2,0,1,0); # leave room for top and bot
&DEBUG("SelectMessage: \$recurse_select is $recurse_select \$currentscreen is $currentscreen\n");
  scrollok($currentscreen,0); # No auto-scrolling

  # Adjust currmsg depending on what's in %msghash
  if (!defined($msghash->{$msgstat->{currmsg}})) {
    foreach $msgindex ( $msgstat->{curmsg} .. $highkey ) {
      if (defined($msgshash{$msgindex})) {
        $msgstat->{currmsg}=$msgindex;
        last;
      }
    } # end foreach
  }

    # Create the title bar
    attron($titlebar,A_REVERSE);
    #addstr($titlebar,"vmsgs $VERSION" . " "x(($COLS/2)-6));
    addstr($titlebar,"vmsgs $VERSION ");
    if ($LOCAL) {
      addstr($titlebar,"(local)           ");
    } else {
      addstr($titlebar,"(from $SERVER)    ");
    }

    # Create the bottom bar
    clear($bottombar);
    ($timestr)=(localtime() =~ m/\d (\d+\:\d+)/);

    $percentshown=0;
    foreach $msgindex (sort(numerically keys(%{$msghash}))) {
      $percentshown++;
      if ($msgindex == $msgstat->{currmsg}) {
        last;
      }
    }
    $percentshown=int(($percentshown / scalar(keys(%{$msghash})))*100);
    attron($bottombar,A_REVERSE);
    addstr($bottombar,"\r-- $timestr -- $msgstat->{mode} -- help:? ---- ");
    if ($percentshown < 10) {  # pad the percent with a space
      addstr($bottombar," ");
    }
    if ($percentshown >= 100) {
      addstr($bottombar,"ALL");
    } else {
      addstr($bottombar,"$percentshown\%");
    }
    addstr($bottombar," ----\cH\cH\cH\cH\cH");

&DEBUG("\$msgstat->{currmsg}:$msgstat->{currmsg}\n");

    # Create the selection screen
    ($firstprinted,$fromtop,$lastprinted)=
      &DisplaySelectScreen($currentscreen,$msgstat->{currmsg},$msghash);
#&DEBUG("refresh 692\n");
#    refresh($currentscreen);
    refresh($titlebar);
    refresh($bottombar);

  do { # until key is (Q)uit

  # Create the titlebar
  $totalmsgs=scalar(keys(%{$msghash}));
  $newmsgs=$highkey-($msgstat->{maxmsg});
  move($titlebar,0,(6+length($VERSION)+($COLS/2)-6));
  addstr($titlebar, "$totalmsgs messages");
  addstr($titlebar, " (" . " "x(4-length($newmsgs)) ."$newmsgs new)") if ($newmsgs >=0);
  refresh($titlebar);

  $percentshown=0;
  foreach $msgindex (sort(numerically keys(%{$msghash}))) {
    $percentshown++;
    if ($msgindex == $msgstat->{currmsg}) {
      last;
    }
  }
  $percentshown=int(($percentshown / scalar(keys(%{$msghash})))*100);
  addstr($bottombar,"\cH\cH\cH");
  if ($percentshown < 10) { # pad a one digit percent with a space
    addstr($bottombar," ");
  }
  if ($percentshown >= 100) {
    addstr($bottombar,"ALL");
  } else {
    addstr($bottombar,"$percentshown\%");
  }
  refresh($bottombar);
&DEBUG("\$percentshown: $percentshown \$msgstat->{currmsg}: " . $msgstat->{currmsg} . "\n");

  &DEBUG("\$newmessages is $newmessages \$recurse_select is $recurse_select\n");
  # If there's new messages, and this is the first level of selection
  if ($newmessages && ($recurse_select==1)) {
&DEBUG("Reloading msghash\n");
    $msghash=$master_msg_hash;  # Get the new messages
    $lowkey=&GetLowestKey($msghash);
    $highkey=&NumMessages();
    ($firstprinted,$fromtop,$lastprinted)=&DisplaySelectScreen(
             $currentscreen,$msgstat->{currmsg},$msghash);

    $newmsgs=$highkey-$msgstat->{maxmsg};
    $newmessages=0;
  }

do { # until hit a legal key
    $legalkey=0;
    # Read in a key to see what to do next
    if (!$DO_ONCE) {
      &DEBUG("First time, redrawing automaticly\n");
      $c = "\cL";
      $DO_ONCE=1;
    } else {
      $c=GetAKey();
    }
    &DEBUG("\$c is $c ASCII " . ord($c) . "\n");
    if (($c eq " ") || ($c eq "\n")) { # Space or newline
      $legalkey=1;
      $oldnewmsgs=$newmsgs;
      &ReadMessage($msghash);
&DEBUG("touchwin 750\n");
      clear($currentscreen);
      ($firstprinted,$fromtop,$lastprinted)=&DisplaySelectScreen(
             $currentscreen,$msgstat->{currmsg},$msghash);

      $newmsgs=$highkey-$msgstat->{maxmsg};
      if ($newmsgs != $oldnewmsgs) {
        addstr($titlebar,"\cH\cH\cH\cH" . " "x(4-length($newmsgs)) . "$newmsgs");
      }
      touchwin($titlebar);  refresh($titlebar);
      touchwin($bottombar);  refresh($bottombar);
    } elsif ($c =~ m/n/i) { # Post or New
      $legalkey=1;
      &PostMessage();
      &sigalrm();  # Read new messages into hash
      if ($recurse_select == 1) {
        $msghash=$master_msg_hash;
      }
      clear($currentscreen);
      &DisplaySelectScreen($currentscreen,$msgstat->{currmsg},$msghash);
      touchwin($titlebar); refresh($titlebar);
      touchwin($bottombar); refresh($bottombar);
    } elsif ($c =~ m/[fr]/i) { # Followup or Reply
      $legalkey=1;
      &Followup($msgstat->{currmsg});
      &sigalrm();  # Read new messages into hash
      if ($recurse_select == 1) {
        $msghash=$master_msg_hash;
      }
      touchwin($currentscreen);
      &DisplaySelectScreen($currentscreen,$msgstat->{currmsg},$msghash);
#&DEBUG("touchwin 778\n");
#      refresh($currentscreen);
      touchwin($titlebar); refresh($titlebar);
      touchwin($bottombar); refresh($bottombar);
    } elsif ($c =~ m/m/i) {  # Mail a reply
      $legalkey=1;
      &MailReply($msgstat->{currmsg});
      &sigalrm();  # Read new messages into hash
      if ($recurse_select == 1) {
        $msghash=$master_msg_hash;
      }
      touchwin($currentscreen);
      &DisplaySelectScreen($currentscreen,$msgstat->{currmsg},$msghash);
    } elsif ($c eq "Q") { # quit all the way
      $legalkey=1;
      $done=1;
    } elsif ($c eq "q") { # quit this mode
      $legalkey=1;
      delwin($titlebar);
      delwin($bottombar);
      $recurse_select--;
      return;
    } elsif ($c =~ m/w/i) {  # Write this msg to a file
      $legalkey=1;
      &WriteFile($msgstat->{currmsg});
      touchwin($currentscreen);
      &DisplaySelectScreen($currentscreen,$msgstat->{currmsg},$msghash);
    } elsif (($c =~ m/j/i) || ($c == KEY_DOWN )) { #Scan forward until we find
      $legalkey=1;
      $c=$msgstat->{currmsg};
      &ScrollSelectionUp();
      if ($c != $msgstat->{currmsg}) {
&DEBUG("refresh 795\n");
        refresh($currentscreen);
      } else {
        beep();
      }
    } elsif (($c =~ m/k/i) || ($c == KEY_UP )) { #Scan backward until we find
      $legalkey=1;
      $c=$msgstat->{currmsg};
      &ScrollSelectionDown();
      if ($c != $msgstat->{currmsg}) {
&DEBUG("refresh 805\n");
        refresh($currentscreen);
      } else {
        beep();
      }
    }  elsif (($c =~ m/h/i) || ($c eq "?")) {
      $legalkey=1;
      &DoHelp($msgstat->{mode});
&DEBUG("touchwin 815\n");
      touchwin($currentscreen);
&DEBUG("refresh 814\n");
      refresh($currentscreen);
    } elsif (($c eq "/") || ($c eq "=")){ # Search mode
      $legalkey=1;
&DEBUG("SelectMessage: \$recurse_select is $recurse_select \$currentscreen is $currentscreen\n");
      &SearchMessages($msghash);
&DEBUG("SelectMessage: back from SearchMessages. mode is $msgstat->{mode}\n");
&DEBUG("SelectMessage: \$recurse_select is $recurse_select \$currentscreen is $currentscreen\n");
      touchwin($titlebar); refresh($titlebar);
      touchwin($bottombar); refresh($bottombar);
      ($firstprinted,$fromtop,$lastprinted)=&DisplaySelectScreen(
             $currentscreen,$msgstat->{currmsg},$msghash);
&DEBUG("touchwin 826\n");
&DEBUG("refresh 826\n");
      touchwin($currentscreen); refresh($currentscreen);
&DEBUG("SelectMessage: Done redrawing stuff\n");
    } elsif (($c eq "\cL") || ($c eq "\cR")) {
      &DEBUG("Refreshing display\n");
      $legalkey=1;
      touchwin($titlebar); refresh($titlebar);
      touchwin($bottombar); refresh($bottombar);
&DEBUG("touchwin 837\n");
      clear($currentscreen);
      ($firstprinted,$fromtop,$lastprinted)=&DisplaySelectScreen(
             $currentscreen,$msgstat->{currmsg},$msghash);
    } elsif ($c eq "C") {  # Catch up mode
      $legalkey=1;
      $msgstat->{'maxmsg'}=$msgstat->{'currmsg'}=&NumMessages();
      touchwin($titlebar); refresh($titlebar);
      touchwin($bottombar); refresh($bottombar);
&DEBUG("touchwin 1175\n");
      clear($currentscreen);
      ($firstprinted,$fromtop,$lastprinted)=&DisplaySelectScreen(
             $currentscreen,$msgstat->{currmsg},$msghash);
    } elsif ($c =~ m/\d/) {
      $legalkey=1;
      if ($c=&GetANumber($c,$msghash)) {
        $msgstat->{currmsg}=$c;
        clear($currentscreen);
      }
      ($firstprinted,$fromtop,$lastprinted)=&DisplaySelectScreen(
                  $currentscreen,$msgstat->{currmsg},$msghash);
      refresh($currentscreen);
    } # end of elsif for entering numbers
} until ($legalkey);

  } until ($c =~ m/q/i);  # end do

  delwin($titlebar);
  delwin($bottombar);
  $recurse_select--;
local($currentscreen);
} # end SelectMessage


sub SearchMessages {
# Given a list of messages to search, it prompts for search criteria
# Then it calls SelectMessage with the new list
my($msghash)=@_;
my($lastmode,$searchby,$key,$msg,$msgdir2,%newhash);
local($currentscreen);

  $lastmode=$msgstat->{mode};
  $msgstat->{mode}="search";

  $currentscreen=newwin(6,60,(int($LINES/2)-3),(int($COLS/2)-30));
  addstr($currentscreen,0,3,"Search Messages");
  addstr($currentscreen,2,3,"Search by (A)uthor, (S)ubject or (W)hole message:");
  addstr($currentscreen,3,3,"Regex string:");

  do {
SEARCH_TRY_AGAIN:
    move($currentscreen,3,16);
    clrtoeol($currentscreen);
    move($currentscreen,2,52);
    clrtoeol($currentscreen);
    box($currentscreen,"|","-");
&DEBUG("refresh 877\n");
    refresh($currentscreen);

    echo();
    $searchby=GetAKey();
    noecho();
    if (! ($searchby =~ m/[asw]/i) ) {
      beep();
      addstr($currentscreen,1,3,"You must enter an 'A', 'S' or 'W'");
    }
  } until ($searchby =~ m/[asw]/i);

  echo();
  getstr($currentscreen,3,16,$key);
  noecho();

  EACH_MSG:
  foreach $msg ( $msgstat->{'firstloaded'} .. $msgstat->{'lastloaded'} ) {
    if ($searchby =~ m/a/i) {
      &LoadHeader($msg);

      if ($msghash->{$msg}->{from} =~ m/$key/) {
        $newhash{$msg}=$msghash->{$msg};
      }
    } elsif ($searchby =~ m/s/i) {
      &LoadHeader($msg);

      if ($msghash->{$msg}->{subject} =~ m/$key/) {
        $newhash{$msg}=$msghash->{$msg};
      }
    } else { # search by any
      &GetHeader($msg);
      &GetBody($msg);

      foreach ( ( @{$msghash->{$msg}->{'header'}} ,
                  @{$msghash->{$msg}->{'text'}}) ) {
        if (m/$key/) {
          $newhash{$msg}=$msghash->{$msg};
          last;
        }
      }
    }
    
  } # end foreach $msg

  delwin($currentscreen);

  if (scalar(keys(%newhash)) == 0) {
    $currentscreen=newwin(5,37,int($LINES/2)-3,int($COLS/2)-18);
    addstr($currentscreen,2,2,"There are no matches for that key");
    box($currentscreen,"|","-");
&DEBUG("refresh 920\n");
    refresh($currentscreen);
    $key=GetAKey();

    delwin($currentscreen);
  } else {
    my $oldcurrmsg=$msgstat->{currmsg};

    $msgstat->{mode}="SearchSelect";
    # set currmsg to the first matching
    ($msgstat->{currmsg})=(sort(numerically keys(%newhash)))[0];
    &SelectMessage(\%newhash);
    $msgstat->{currmsg}=$oldcurrmsg;
  }

  $msgstat->{mode}=$lastmode;
} # end SearchMessages


sub DoneCursesWindows {
# Shuts down the curses stuff
local(%screen)=@_;

  echo();
  nocbreak();
  endwin();
  `stty echo`;
}


sub ReadMessage {
# Start printing messages starting with $msgstat{currmsg}. The hash of
# valid messages is passed in as the first arg
my($msghash)=@_;

  my($numlines,$c,$msgsleft,$timestr,$lastmode,$msgdir2,$msgref,$msglen,$first);
  my($from,$subject,$month,$date,$year,$percentdone,$legalkey,$showheader);
  local($titlebar,$bottombar,$currentscreen);

  $highkey=&NumMessages();
  $lowkey=&GetLowestKey($msghash);

  $titlebar=newwin(1,0,0,0) || die "titlebar";
  scrollok($titlebar,0);
  $bottombar=newwin(1,0,$LINES-1,0) || die "bottombar";

&DEBUG("In ReadMessage \$highkey: $highkey \$lowkey: $lowkey\n");

  $lastmode=$msgstat->{mode};
  $msgstat->{mode}="reading";

  $currentscreen=newwin($LINES-2,0,1,0);

  $showheader=0; # Default is don't show the headers

  SHOW_ONE_MESSAGE:
  # Until done reading messages
  while ($msgstat->{currmsg} <= $highkey) {

&DEBUG("In ReadMessage:SHOW_ONE_MESSAGE\n");

    if ($showheader) {
&DEBUG("Showing Header\n");
      $msgref=&LoadHeader($msgstat->{'currmsg'});
    } else {
&DEBUG("Showing body\n");
      $msgref=&LoadBody($msgstat->{'currmsg'});
    }

    # Keep track of the highest numbered message so far
    if ($msgstat->{currmsg} > $msgstat->{maxmsg}) {
      $msgstat->{maxmsg} = $msgstat->{currmsg};
    }

    $numlines=0; # How many lines we've printed of this message

    ($month,$date,$timestr,$year)=($msghash->{$msgstat->{currmsg}}->{date} =~
                 m/\w+\s+(\w+)\s+(\d+)\s+(\d+\:\d+)\:\d+\s+(\d+)/);

&DEBUG("ReadMessage point1\n");

    # Create the titlebar
    attroff($titlebar,A_REVERSE);
    clear($titlebar);
    attron($titlebar,A_REVERSE);
    addstr($titlebar,"\r$msghash->{$msgstat->{currmsg}}->{from}: " .
           substr($msghash->{$msgstat->{currmsg}}->{subject},0,50));
    addstr($titlebar,0,($COLS-20),"$date $month $year $timestr");
    refresh($titlebar); # This won't change during this message

    $msglen = scalar(@{$msgref});
    $numlines = 0;

    SHOW_ONE_PAGE:
    while ($numlines <= $msglen) {

      &DEBUG("In ReadMessage:SHOW_ONE_PAGE\n");

      # create the message window
      if ($opt_scroll) {
        scrollok($currentscreen,1);
        idlok($currentscreen,1);
        setscrreg($currentscreen,0,$LINES-2);
        syncok($currentscreen,1);
        addstr($currentscreen,"\n" . "-"x75 . "\n") if ($first++);
        addstr($currentscreen,"From ".$msghash->{$msgstat->{currmsg}}->{from});
        addstr($currentscreen,"\nSubject: ".
                              $msghash->{$msgstat->{currmsg}}->{subject}.
                              "\n\n");
                              
      } else {
        clear($currentscreen);
      }

      addstr($currentscreen,join(($showheader && ! $LOCAL) ? "\n" : "",
             @{$msgref}[$numlines .. ($numlines + $LINES - 3)]));
      $numlines += ($LINES-3);

&DEBUG("ReadMessage: \$numlines is $numlines\n");

      ($timestr)=(localtime() =~ m/\d (\d+\:\d+)/);  # Get the current time
      # How many more to go?
      $msgsleft=$highkey-$msgstat->{currmsg};

      # Create the bottom bar
      attroff($bottombar,A_REVERSE);
      clear($bottombar);
      attron($bottombar,A_REVERSE);
      addstr($bottombar,"\r-- $timestr -- " . $msgstat->{currmsg} . " -- ");
      if ($msgsleft == 0) {
        addstr($bottombar,"LAST");
      } else {
        addstr($bottombar,"$msgsleft MORE");
      }
      addstr($bottombar," --help:?-- ");

      $percentdone = (scalar(@{$msgref}) == 0) ?
                     100 :
                     int($numlines / scalar(@{$msgref}) * 100);
      if ($percentdone >= 100) {
        addstr($bottombar,"ALL --");
      } else {
        addstr($bottombar,"$percentdone% --");
      }
&DEBUG("refresh 1064\n");
      refresh($currentscreen);
      refresh($bottombar);

      do { # Until we get a legal key
        $legalkey=0;
        # Get a key and do something
        $c=GetAKey();

&DEBUG("ReadMessage: getch got a \"$c\"\n");
        if ($c =~ m/[fr]/i) { # Followup or Reply
          $legalkey=1;
          &Followup($msgstat->{currmsg});
&DEBUG("refresh 1077\n");
          refresh($currentscreen);
          &sigalrm();  # Reread new messages into hash
        } elsif ($c =~ m/q/i) { # Quit
          $legalkey=1;
          $done=1 if ($c eq "Q");
          delwin($currentscreen);
          $msgstat->{mode}=$lastmode;
          delwin($titlebar);
          delwin($bottombar);
          return;
        } elsif ($c eq "?") {
          $legalkey=1;
          &DoHelp($msgstat->{mode});
&DEBUG("refresh 1091\n");
          refresh($currentscreen);
        } elsif (($c eq " ") || ($c eq "\n")) {
          $legalkey=1;
          next SHOW_ONE_PAGE;
        } elsif ($c =~ m/w/i) {  # write msg to a file
          &WriteFile($msgstat->{currmsg});
          touchwin($currentscreen);
          refresh($currentscreen);
        } elsif ($c =~ m/[si]/i) {  # select or index
          $legalkey=1;
          delwin($currentscreen);
          $msgstat->{mode}=$lastmode;
          delwin($titlebar);
          delwin($bottombar);
          return;
        } elsif (($c eq "\cH") || ($c eq "\c?")) {  # Back 1 page
          $legalkey=1;
          $numlines -= ($LINES-2);
          if ($numlines < 0) {
            $numlines=0;
          }
          next SHOW_ONE_PAGE;
        } elsif ($c =~ m/m/i) {  # mail reply
          $legalkey=1;
          &MailReply($msgstat->{currmsg});
          refresh($currentscreen);
          &sigalrm();  # Reread new messages into hash
        } elsif ($c =~ m/h/i) {  # print headers
          $numlines=0;
          $showheader= ! $showheader;
          next SHOW_ONE_MESSAGE;
        } elsif ($c =~ m/n/i) {  # Next message
          $showheader=0;
          $legalkey=1;
          # Search for the next valid message
          $c=&NextMessageForward($msgstat->{currmsg},$msghash,$highkey);
&DEBUG("Skipping to next message \$msgstat->{currmsg}: $msgstat->{currmsg} \$c: $c\n");
          if (($c == $msgstat->{currmsg}) || ($msgstat->{currmsg}>=$highkey)) {
            delwin($currentscreen);
            $msgstat->{mode}=$lastmode;
            delwin($titlebar);
            delwin($bottombar);
            return;
          } else {  # If it changed...
            $msgstat->{currmsg}=$c;
            next SHOW_ONE_MESSAGE
          }
        } elsif ($c =~ m/p/i) { # Previous message
          $showheader=0;
          $legalkey=1;
          # Search for the first previous valid message
          $c=&NextMessageBackward($msgstat->{currmsg},$msghash,$lowkey);
&DEBUG("Skipping to previous message \$msgstat->{currmsg}: $msgstat->{currmsg} \$c: $c\n");
          if (($c == $msgstat->{currmsg}) || ($msgstat->{currmsg}<=$lowkey)) {
            delwin($currentscreen);
            $msgstat->{mode}=$lastmode;
            delwin($titlebar);
            delwin($bottombar);
            return;
          } else  {  # If it changed...
            $msgstat->{currmsg}=$c;
            next SHOW_ONE_MESSAGE
          }
        }
      } until ($legalkey);

    } # while $numlines < $#themessage

    $showheader=0;
    # Search for the next valid message
    $c=$msgstat->{currmsg};
    do {
      $c++;
    } until ( defined($msghash->{$c}) || ($c > $highkey));
&DEBUG("ReadMessage: next \$msgstat->{currmsg} is $msgstat->{currmsg}\n");
    if (defined($msghash->{$c})) {  # If it changed...
      $msgstat->{currmsg}=$c;
      next SHOW_ONE_MESSAGE
    } else { # That was the last message
      delwin($currentscreen);
      $msgstat->{mode}=$lastmode;
      $msgstat->{'currmsg'}=$msgstat->{'lastmsg'};
&DEBUG("ReadMessage: returning. \$msgstat->{currmsg}: $msgstat->{currmsg} \$c: $c\n");
      delwin($titlebar);
      delwin($bottombar);
      return;
    }
  } # while $msgstat->{currmsg} <= $highkey

  delwin($currentscreen);
  $msgstat->{mode}=$lastmode;
} # end ReadMessage



sub WriteFile {
# Writes a message to a file
my($msg)=@_;
  my($filename,$answer,$stuff,$line);
  my($win)

&DEBUG("In WriteFile\n");

  $win=newwin(5,50,int($LINES/2)-3,int($COLS/2)-25);
  addstr($win,1,16,"Write msg to file");
  addstr($win,2,3,"Filename:");
  clrtoeol($win);
  box($win,"|","-");
  refresh($win);

  echo();
  getstr($win,2,13,$filename);
  noecho();
&DEBUG("WriteFile: got $filename\n");

  $filename =~ s/^\s+//;
  $filename =~ s/\s+$//;
  if (length($filename)) {
    if ($filename =~ m/^~/) {
      $filename=&GetHomeDir($filename);
    }

    &DEBUG("WriteFile: Opening $filename for appending...\n");
    if (!open(SAVE,">>$filename")) {
      &DEBUG("WriteFile: Can't open: $!\n");
      clear($win);
      box($win,"|","-");
      addstr($win,0,19," Error ");
      addstr($win,1,3,"Cannot open $filename for writing");
      addstr($win,2,3,$!);
      beep();
      refresh($win);     
      &GetAKey();
      goto LEAVE_WRITEFILE;
    }

    $stuff = &LoadHeader($msg);
    foreach $line (  @{$stuff} ) {
      &DEBUG("WriteFile: Writing $line");
      print SAVE "$line";
    }
    print SAVE "\n";
    $stuff = LoadBody($msg);
    foreach $line ( @$stuff ) {
      &DEBUG("WriteFile: Writing $line");
      print SAVE "$line";
    }
    print SAVE "\n";
    close(SAVE);
  } # end if length($filename)

LEAVE_WRITEFILE:
  delwin($win);
&DEBUG("Leaving WriteFile\n");
} # end WriteFile


sub GetHomeDir {
# Massages the input filename if it starts with ~login
my($file) = @_;
  my($name,$dir);

  &DEBUG("In GetHomeDir\n");

  ($name,$file) = ($file =~ m/^~(\S*)(\/.*)/);
  &DEBUG("GetHomeDir: Split into name $name and file $file\n");

  if (!$name) {
    $dir = $ENV{'HOME'};
  } else {
    $dir = (getpwnam($name))[7] | "~$name";
  }

  &DEBUG("GetHomeDir: home dir is $dir returning " . $dir . $file . "\n");

  $dir.$file;
} # end GetHomeDir

  


sub PostMessage {
# Creates a new message
  my($pid,$filename,$date,$subject,$msgname,$oldmode,$msgdir2);
  my($numlines,$headerlen,$c,$umask,@text);
  local($currentscreen);

&DEBUG("In PostMessage\n");

  $oldmode=$msgstat->{mode};
  $msgstat->{mode}="post";

  $pid=$$;
  $filename="/$ENV{'HOME'}/newmsgs.$pid";   # Temporary filename for editing
&DEBUG("Temp filename is $filename\n");
  $date=localtime();

  $currentscreen=newwin(5,50,int($LINES/2)-3,int($COLS/2)-25);
  addstr($currentscreen,0,int($COLS/2)-5,"New Message");
  addstr($currentscreen,2,3,"Subject:");
  clrtoeol($currentscreen);
  box($currentscreen,"|","-");
&DEBUG("refresh 1195\n");
  refresh($currentscreen);

  echo();
  getstr($currentscreen,2,12,$subject);
  delwin($currentscreen);
  noecho();

  if (!($subject =~ m/\S/) ) {
    $currentscreen=newwin(5,50,int($LINES/2)-3,int($COLS/2)-25);
    box($currentscreen,"|","-");
    addstr($currentscreen,1,int($COLS/2)-30,"No subject.  Continue Message?");
    addstr($currentscreen,2,int($COLS/2)-20,"(Y/N)");
    refresh($currentscreen);
    do {
      $c=GetAKey();
    } until (($c=~m/n/i) || ($c=~m/y/i));
    if ($c=~m/n/i) {
      unlink($filename);
      delwin($currentscreen);
      $msgstat->{mode}=$oldmode;
      return;
    }
  }

  # Create the header for the message
  open(FILE,">$filename");
  print FILE "From $AUTHOR \($EMAIL\) $date\n";
  print FILE "Subject: $subject\n";
  print FILE "X-msgs-client: vmsgs $VERSION\n";
  print FILE "Msgs-Posting-Host: ",$ENV{'HOST'},"\n" if (!$LOCAL);
  print FILE "\n\n";
  close(FILE);
  &AppendSig($filename);

  echo();
  #alarm(0);  # Turn off the auto refresh
  system("$EDITOR +6 $filename");  # Edit the file
  #alarm(60);
  noecho();

  $currentscreen=newwin(6,30,int($LINES/2)-3,int($COLS/2)-15);
  attron($currentscreen,A_BOLD);
  addstr($currentscreen,2,5,"S");
  attroff($currentscreen,A_BOLD);
  addstr($currentscreen,"end it, ");
  attron($currentscreen,A_BOLD);
  addstr($currentscreen,"F");
  attroff($currentscreen,A_BOLD);
  addstr($currentscreen,"orget it,");
  addstr($currentscreen,3,3,"or ");
  attron($currentscreen,A_BOLD);
  addstr($currentscreen,"D");
  attroff($currentscreen,A_BOLD);
  addstr($currentscreen,"ump into /dev/null?");
  box($currentscreen,"|","-");
&DEBUG("refresh 1226\n");
  refresh($currentscreen);

    do {
    $c=GetAKey();
  } until ($c =~ m/[sfd]/i);

  if ($c =~ m/s/i) {
    open(FILE,"$filename");
    @text=<FILE>;
    close(FILE);

    # Count how many lines is in the body
    $count=scalar(@text) - 4;
    $text[2] = $text[2] . "Content-length: $count\n";

    &Post(join("",@text));
  }

  unlink($filename);

  delwin($currentscreen);

  $msgstat->{mode}=$oldmode;

} # end PostMessage


sub Followup {
# Posts a followup to the message given as the first arg
my ($msgnum)=@_;

  my($pid,$filename,$date,$subject,$c,$msgname,$from,$oldmode);
  my($umask,$msgdir2,$msgref);
  local($currentscreen);

&DEBUG("In Followup\n");

  $oldmode=$msgstat->{mode};
  $msgstat->{mode}="followup";

  $pid=$$;
  $filename="$ENV{'HOME'}/newmsgs.$pid";
&DEBUG("Temp filename is $filename\n");
  $date=localtime();

  &LoadHeader($msgnum);

  $subject=$master_msg_hash->{$msgnum}->{subject};
  if ($subject =~ m/^Re\:(.*)/) {
    $subject="Re[2]:$1";
  } elsif ($subject =~ m/^Re\[(\d+)\]\:(.*)/) {
    $subject="Re[". ($1 + 1) ."]:$2";
  } else {
    $subject = "Re: $subject";
  }

  $msgref=&LoadBody($msgnum);

    &DEBUG("Followup: Creating the followup message\n");
  open(FILE,">$filename");
  print FILE "From $AUTHOR \($EMAIL\) $date\n";
  print FILE "Subject: $subject\n";
  print FILE "Followup-to: $msgnum\n";
  print FILE "X-msgs-client: vmsgs $VERSION\n";
  print FILE "Msgs-Posting-Host: ",$ENV{'HOST'},"\n" if (!$LOCAL);

  print FILE "\n";
  print FILE $master_msg_hash->{$msgnum}->{from} . " wrote:\n";

  $numlines=6;
  foreach (@{$msgref}) {
    print FILE "\> $_";
    $numlines++;
  }
  $numlines += 2;  # Just 'cause
  print FILE "\n";
  close(FILE);

  &AppendSig($filename);

  echo();

  #alarm(0);
&DEBUG("Followup: execing $EDITOR\n");
  system("$EDITOR +$numlines $filename");
&DEBUG("Followup: back from $EDITOR\n");
  #alarm(60);

  noecho();

  $currentscreen=newwin(6,30,int($LINES/2)-3,int($COLS/2)-15);
  attron($currentscreen,A_BOLD);
  addstr($currentscreen,2,5,"S");
  attroff($currentscreen,A_BOLD);
  addstr($currentscreen,"end it or ");
  attron($currentscreen,A_BOLD);
  addstr($currentscreen,"F");
  attroff($currentscreen,A_BOLD);
  addstr($currentscreen,"orget it,");
  addstr($currentscreen,3,3,"or ");
  attron($currentscreen,A_BOLD);
  addstr($currentscreen,"D");
  attroff($currentscreen,A_BOLD);
  addstr($currentscreen,"ump into /dev/null?");
  box($currentscreen,"|","-");
&DEBUG("refresh 1311\n");
  refresh($currentscreen);

  do {
    $c=GetAKey();
  } until ($c =~ m/[sfd]/i);
&DEBUG("Followup: getch got $c\n");

  if ($c =~ m/s/i) {
    my(@text);

    open(FILE,"$filename");
    @text=<FILE>;
    close(FILE);

    # Count how many lines are in it
    $count=scalar(@text) - 6;
    $text[3] = $text[3] . "Content-length: $count\n";

    &Post(join("",@text));
  }
  unlink($filename);

  clear($currentscreen);
&DEBUG("refresh 1326\n");
  refresh($currentscreen);
  delwin($currentscreen);

  $msgstat->{mode}=$oldmode;

} # end Followup



sub MailReply {  # Mails a reply to the current message
my ($msgnum)=@_;

  my($pid,$filenamer,$date,$subject,$c,$msgname,$from,$oldmode);
  my($umask,$msgdir2,$return,$msgref);
  local($currentscreen);

&DEBUG("In MailReply($msgnum)\n");

  $oldmode=$msgstat->{mode};
  $msgstat->{mode}="mailreply";

  $pid=$$;
  $filename="$ENV{'HOME'}/newmsgs.$pid";
&DEBUG("Temp filename is $filename\n");
  $date=localtime();

  $subject=$master_msg_hash->{$msgnum}->{subject};
  if ($subject =~ m/^Re\:(.*)/) {
    $subject="Re[2]:$1";
  } elsif ($subject =~ m/^Re\[(\d+)\]\:(.*)/) {
    $subject="Re[". ($1 + 1) ."]:$2";
  } else {
    $subject = "Re: $subject";
  }

  if (! $master_msg_hash->{$msgnum}->{text}) {
    my(@text);

    @text=&GetBody($msgnum);
    if (scalar(@text) == 0) {
      &DEBUG("GetBody returned nothing for message $msgnum\n");
    }
    $msgref=\@text;
  } else {
    $msgref=$master_msg_hash->{$msgnum}->{text};
  }

  open(FILE,">$filename");
  print FILE "you wrote in msgs:\n";

  foreach (@{$msgref}) {
    print FILE "\> $_";
    $numlines++;
  }
  $numlines += 2;  # Just 'cause
  print FILE "\n";
  close(MSG);
  close(FILE);
  &AppendSig($filename);

  echo();

  #alarm(0);
&DEBUG("MailReply: execing $EDITOR\n");
  system("$EDITOR +$numlines $filename");
&DEBUG("MailReply: back from $EDITOR\n");
  #alarm(60);

  noecho();

  $currentscreen=newwin(6,30,int($LINES/2)-3,int($COLS/2)-15);
  attron($currentscreen,A_BOLD);
  addstr($currentscreen,2,3,"S");
  attroff($currentscreen,A_BOLD);
  addstr($currentscreen,"end it or ");
  attron($currentscreen,A_BOLD);
  addstr($currentscreen,"F");
  attroff($currentscreen,A_BOLD);
  addstr($currentscreen,"orget it?");
  box($currentscreen,"|","-");
&DEBUG("refresh 1311\n");
  refresh($currentscreen);

  do {
    $c=GetAKey();
  } until ($c =~ m/[sf]/i);
&DEBUG("MailReply: getch got $c\n");

  if ($master_msg_hash->{$msgnum}->{email}) {
    $from = $master_msg_hash->{$msgnum}->{email};
  } else {
    $from = $master_msg_hash->{$msgnum}->{from};
  }

  if ($c =~ m/s/i) {
&DEBUG("Getting ready to mail the reply\n");
    $return=system("elm -s \"$subject\" $from < $filename");
    $return /= 256;
    unlink("$filename");
&DEBUG("Back from elm.  Got return code $return\n");
  } else {
    unlink($filename);
  }
  clear($currentscreen);
&DEBUG("refresh 1326\n");
  refresh($currentscreen);
  delwin($currentscreen);

  $msgstat->{mode}=$oldmode;

  &DEBUG("leaving MailReply\n");
} # end MailReply



sub aaaaggghhhh {
# Saves the .msgsrc file before dying
  my($worked);

  if (!$msgstat{maxmsg}) {
    $worked=&SetRC(&NumMessages());
  } else {
    $worked=&SetRC($msgstat{maxmsg}+1);
  }

  if ($curses_on) {
    &DoneCursesWindows(%screen);
  }
  print "\n";
  print "Your msgsrc didn't save correctly...\n" if (!$worked);
  exit(1);
}


sub sigcont {
# Puts the terminal back into cool mode. Hopefully your shell takes care of
# putting it into normal mode when you hit ^Z
  if (! -f "/tmp/newmsgs.$$") {
    noecho();
    cbreak();
    #alarm(60);
  }
}


sub sigalrm {
# Called every 60 seconds.  Rereads the bounds file to get message updates
  my($count,$header,$text,$oldlastmsg,$num);

&DEBUG("In sigalrm\n");
  #alarm(0);

  if ($msgstat->{'lastmsg'} > $msgstat->{'lastloaded'}) {
    foreach ( 1 .. 5 ) {
      $msgstat->{'lastloaded'}++;
      &DEBUG("Loading header for msg " . $msgstat->{lastloaded} . "\n");
      $header=&LoadHeader($msgstat->{lastloaded});
      if ($CACHE_MSGS) {
        $master_msg_hash->{$msgstat->{'lastloaded'}}->{'header'}=$header;
      }
 
      last if ($msgstat->{'lastloaded'} == $msgstat->{'lastmsg'});

    } # end foreach

    $newmessages=1;
    if ($msgstat->{mode} eq "selection") {
      &DEBUG("Displaying new msgs in sigalrm\n");
      &DisplaySelectScreen($currentscreen,$msgstat->{currmsg},
                           $master_msg_hash);
      &DEBUG("** ungetch-ing a ^L\n");
      ungetch(ord("\cL"));
    }

  } elsif ($msgstat->{'lastmsg'} != ($num = &NumMessages())) {
    $oldlastmsg = $msgstat->{'lastmsg'};
    $msgstat->{'lastmsg'} = $num;

    foreach $num ( ($oldlastmsg + 1) .. $msgstat->{'lastmsg'}) {
      &LoadMsg($num);
    }

    $newmessages=1;
    if ($msgstat->{mode} eq "selection") {
      &DEBUG("Displaying new msgs in sigalrm\n");
      &DisplaySelectScreen($currentscreen,$msgstat->{currmsg},
                           $master_msg_hash);
      &DEBUG("** ungetch-ing a ^L\n");
      ungetch(ord("\cL"));
    }
  } # end elsif

  &DEBUG("Leaving sigalrm\n");
  #alarm(60);
} # end sigalrm
    

sub DoHelp {
local($mode)=@_;
local($window,$c);

  $window=newwin($LINES-2,0,1,0);
  clear($window);
  addstr($window,"Help for mode $mode\n\n");

  if (($mode eq "selection") || ($mode eq "SearchSelect")) {
    addstr($window,"
<space> and <enter> - Read the currently selected message
n      - Create a new message
f or r - Followup to the current message
m      - Mail a reply to this message
w      - Write this message to a file
j      - Go to the next message
k      - Go the the previous message
C      - Catch up to all messages
?      - Get this help screen
/ or = - Search for a message
^L     - Redraw the screen
Q      - Go back one selection screen
         Capital Q to exit the program

You may also enter a number to go directly to that message number

Hit any key to continue
");
    refresh($window);
    $c=GetAKey();
  } elsif ($mode eq "reading") {
    addstr($window,"
<space> or <enter> - Go to the next page, or next message if last page
<backspace> - Go back one page
f or r - Followup to the current message
m      - Mail a reply to this message
w      - Write this message to a file
?      - Get this help screen
h      - Print the headers for this message
s or i - Go back to the message selection screen
n      - Go to the next message
p      - Go to the previous message

Hit any key to continue
");
    refresh($window);
    $c=GetAKey();
  }

  delwin($window);
}



sub GetCommandLine {
# Processes command line options. Works line Getopt in that it sets
# $opt_argname

  my($i,$lastvar);

  if (-f ".vmsgsrc") {
    open(RC,".vmsgsrc");
    while(<RC>) {
      if (m/^-?(\w+)/) {
        &DEBUG("defining \$opt_$1\n");
        eval "\$opt_$1 = 1";
      } elsif (m/^-(\w+)\s+(.*)$/) {
        &DEBUG("setting \$$1 to $2\n");
        eval "\$opt_$1 = $2";
      }
    }
    close(RC);
  } else {
     
    foreach $i ( 0 .. $#ARGV ) {
      if ($ARGV[$i] =~ m/^-(\w*)/) {
        &DEBUG("defining \$opt_$1\n");
        eval "\$opt_$1 = 1";
        $lastvar="opt_$1";
      } else {
        &DEBUG("setting \$$lastvar to $ARGV[$i]\n");
        eval "\$$lastvar = $ARGV[$i]";
      }
    }
  }
}  # end GetCommandLine


sub AppendSig {
# Puts the contents of your .msgssig file to the end of a message
# The tmp filename of the message is given as the first arg
my($filename)=@_;


  if (-f "${ENV{'HOME'}}/.msgssig") {
&DEBUG("Appending sig to $filename\n");

    open(FILE,">>$filename");
    open(SIG,"$ENV{'HOME'}/.msgssig");
    seek(FILE,0,2);

    print FILE "\n";  # Put in a blank line to look nice
    while(<SIG>) {
      print FILE $_;
    }
    close(FILE);
    close(SIG);
  }
}  # end AppendSig


sub DoCommandLineHelp {
  print "Command Line Options for vmsgs:
-m <#> Start reading msgs at msg number #
-k    Ignore your kill file
-r    Read remotely
-s <name> Set msgs server in remote mode
-c    Force caching of msgs (Default if in remote mode)
-n    Don't cache msgs (Default if in local mode)
-a    Set read ahead size (Default is 5)
-C    Catch up to all messages
-scroll Scroll msgs instead of redrawing in read mode
";

}


sub GetLines {
# Gets the number of lines on the screen without curses
  local(*FILE);

  open(FILE,"stty -a |");
  while(<FILE>) {
    DEBUG("GetLines: stty got $_");
    if (m/rows (\d+)/) {
      close(FILE);
      &DEBUG("GetLines: returning $1\n");
      return $1;
    }
  }

  &DEBUG("GetLines: wierd stty reply.  Returning 0\n");
  close(FILE);
  return 0;
} # end GetLines




sub AsyncRead {
# Performs background readahead.  Passed in arg is the first msg to start
# Immediately returns with the first message.  Readahead is done in the
# background.  Only one read ahead operation is allowed at a time.  When
# the read ahead is done, it sends the parent a SIGUSR2
my($msg,$type)=@_;
  my($thingy,$timeleft,$thing2,@thingy);

  &DEBUG("In AsyncRead\($msg,$type\)\n");

  if ($master_msg_hash->{$msg}->{'pending'}) {
    while ($master_msg_hash->{$msg}->{'pending'}) {
      &DEBUG("AsyncRead: $type $msg is pending...\n");
      select(undef,undef,undef,0.01);
    }
    &DEBUG("AsyncRead: $type $msg is done pending!\n");
    return $master_msg_hash->{$msg}->{$type};
  }

  if ($type eq "header") {
    @thingy=&GetHeader($msg);
  } elsif ($type eq "text") {
    @thingy=&GetBody($msg);
  }

  # Break-up for lines that are longer than the width of the terminal
  foreach $thingy2 ( @thingy ) {
    if (length($thingy2) > $COLS) {
      push(@$thingy, substr($thingy2, 0, $COLS));  # push the first of the string
      substr($thingy2, 0, $COLS) = "";   # chop off what we pushed
    }
    push(@$thingy, $thingy2);   # now push anyhting that's left
  } # end foreach


  if ((!$CACHE_MSGS) || (! scalar(@{$thingy}))) {   # If not caching...
    return $thingy;     # we don't do any readahead
  }

  pipe(FROMCHILD,TOPARENT);

#  $ALARM_LEFT=alarm(0);
  $timeleft=0;
  while ($ASYNC_LOCK) {
    die "Timeout on Async_lock!" if ($timeleft++ == 1000);
    # Wait until previous async operation is done
    &DEBUG("AsyncRead: Waiting on lock...\n");
    select(undef,undef,undef,0.01);

    &RealSigIO() if ($async_ready);
  }
  
  if ($master_msg_hash->{$msg}->{$type}) {
    &DEBUG("AsyncRead: Previous async op already got msg $msg\n");
    return $master_msg_hash->{$msg}->{$type};
  }
  $ASYNC_LOCK=1;
  &DEBUG("AsyncRead: got lock\n");

  if (fork()) {
    $SIG{'USR2'}=\&sigIO;

    &DEBUG("AsyncRead: in Parent\n");   
    close(TOPARENT);

    foreach ( 1 .. $opt_a ) {
      $msg++;
      last if ($msg > $msgstat->{'lastmsg'});
      &DEBUG("AsyncRead-Parent: Marking msg $msg as pending\n");
      $master_msg_hash->{$msg}->{'pending'}=1;
    }

    &DEBUG("AsyncRead-Parent: returning\n");
    return $thingy;

  } else { # Child process

    my($buffer,$line);
    close(FROMCHILD);

    &DEBUG("In AsyncRead Child\n");

    foreach ( 1 .. $opt_a ) {
      $msg++;

      if (($msg > $msgstat->{'lastmsg'}) || ($msg < $msgstat->{'firstmsg'})) {
        kill('USR2', getppid());
        last;
      }

      if ($master_msg_hash->{$msg}->{$type}) {
        &DEBUG("AsyncRead-Child: $type already exists for msg $msg\n");
      } else {
        &DEBUG("AsyncRead-Child: getting $type for msg $msg\n");

        if ($type eq "header") {
          $buffer=[ &GetHeader($msg) ];
          kill('USR2',getppid()) || &DEBUG("Didn't send sigusr2!!\n");
          print TOPARENT "header $msg\n";
        } elsif ($type eq "text") {
          $buffer=[ &GetBody($msg) ];
          kill('USR2',getppid()) || &DEBUG("Didn't send sigusr2!!\n");
          print TOPARENT "text $msg\n";
        }
        &DEBUG("AsyncRead-Child: signalled parent that data is ready for msg $msg\n");

        foreach $line ( @{$buffer} ) {
          &DEBUG("AsyncRead-Child: sending $line");
          print TOPARENT $line;
        }

        print TOPARENT ".\n";
        &flush(TOPARENT);
      }
    }

    select(undef,undef,undef,0.10);
    kill('USR2',getppid());
    print TOPARENT "done 0\n";
    &flush(TOPARENT);
    close(TOPARENT);
    &DEBUG("AsyncRead: Child is done!!\n");
    
    exit(0);
  }
} # end AsyncRead


sub GetAKey {
# Wrapper for getch().  It checks to see if there's an async operation 
# ready 
  my($char,$min);

  #keypad(1);


  do {
    $char=getch();

    ($min) = (scalar(localtime()) =~ m/:(\d+):/);
    if ($min != $LAST_SPOOL_READ) {
      &DEBUG("min changed to $min... sigalrm-ing\n");
      &sigalrm();
      $LAST_SPOOL_READ = $min;
    }

    if ($async_ready) {
      &RealSigIO();
    }
#    &DEBUG("GetAKey: \$char $char length " . length($char) . "ERR " . ERR . "\n");
  } until ($char != -1);

  $char;
} # end GetAKey

sub sigIO {
# Called when an async read operation completes
  $async_ready++;
  &DEBUG("In sigIO.  \$async_ready is $async_ready");

  $SIG{'USR2'}=\&sigIO;
}


sub RealSigIO {
# Called by GetAKey when there's data ready after an async IO operation
  my($lines,$type,$msg);

  if (!$async_ready <= 0) {
    &DEBUG("RealSigIO called when nothing ready?!?\n");
    return;
  }

  &DEBUG("In RealSigIO\n");

  ($type,$msg) = (scalar(<FROMCHILD>) =~ m/^(\w+) (\d+)/);
  &DEBUG("sigIO: \$type $type \$msg $msg\n");
  
  if ($type && ($type ne "done")) {
    $_=<FROMCHILD>;
    while ($_ ne ".\n") {
      &DEBUG("RealSigIO: got $_");
      push(@{$lines},$_);
      $_=<FROMCHILD>;
    }
  }

  if ($type eq "header") {
    &ParseHeader($msg,$lines);

    if ($msgstat->{firstloaded} > $msg) {
      &DEBUG("RealSigIO: updating firstloaded to $msg\n");
      $msgstat->{firstloaded} = $msg;
    } elsif ($msgstat->{lastloaded} < $msg) {
      &DEBUG("RealSigIO: updating lastloaded to $msg\n");
      $msgstat->{lastloaded} = $msg;
    }

    $master_msg_hash->{$msg}->{'header'}=$lines;
    &DEBUG("RealSigIO: Marking msg $msg not pending\n");
    $master_msg_hash->{$msg}->{'pending'}=0;

  } elsif ($type eq "text") {
    $master_msg_hash->{$msg}->{'numlines'}=scalar(@{$lines});

    $master_msg_hash->{$msg}->{$type}=$lines;
    &DEBUG("RealSigIO: Marking msg $msg not pending\n");
    $master_msg_hash->{$msg}->{'pending'}=0;
  } 

  if (($type eq "done") || eof(FROMCHILD)) {
    &DEBUG("RealSigIO: Child was done\n");
    close(FROMCHILD);
    wait();
    &DEBUG("RealSigIO: Clearing Async Lock\n");
    $ASYNC_LOCK=0;
    $async_ready--;
    #if ($ALARM_LEFT>0) {
    #  alarm($ALARM_LEFT);
    #} else {
    #  alarm(60);
    #}
  }    

  &DEBUG("Leaving RealSigIO\n");
}

  


